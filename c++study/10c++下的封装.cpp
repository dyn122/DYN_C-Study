//C++下如果不声明权限，默认是private
//private权限在类的内部可以访问，在外部不可访问，子类不可以访问
//public权限在类外部可以访问
//protected保护权限，类内部可以访问，当前类的子类可以访问，外部不可访问4

//建议将所有的成员变量的权限设置为private,通过公有的方法来访问私有的成员变量

//类的结构
#include <iostream>
using namespace std;
class DYN
{
public:
	DYN()//构造函数
	{
		cout << "构造函数" << endl;
	}




	~DYN()
	{
		cout << "析构函数" << endl;
	}
};
void test10()
{
	DYN dyn1;
}
void main10()
{
	test10();
	system("pause");
	EXIT_SUCCESS;

}
/*
构造函数可以发生重载
构造函数的分类
1.按照参数进行分类，无参构造函数（默认构造函数）、有参构造函数
2.按照类型进行分类，拷贝构造函数

拷贝构造函数的写法：
DYN（const DYN & d1)
{
  //code
}
有参构造函数的调用
DYN d2(100);
DYN d3 = DYN(100);
匿名调用 DYN(100) 这行代码结束时即把对象释放
不能用拷贝构造函数初始化匿名对象，即DYN(p1)，编译器会理解为DYN p1导致报重复定义
只能用左值的方法调用拷贝的构造函数

*当提供有参的构造函数时，系统就不提供默认构造函数了（无参构造函数）
系统正常情况下会提供构造函数，拷贝构造函数，析构函数

*当我们提供拷贝构造时，系统就不会提供其他构造了，包括默认构造
*/

//深拷贝与浅拷贝
/*
系统默认一般是浅拷贝，位于堆区的变量只拷贝了地址，而没有建立新的堆空间，浅拷贝会导致重复释放内存异常，需要自己提供拷贝构造函数
深拷贝就是拷贝所有的东西，包括堆空间，即需要开辟新的堆空间
*/

//利用初始化列表来初始化数据
/*
Person(int a,int b, int c):A(a),B(b),C(c)
{
}
*/

//类对象作为类成员时，现将类成员一一构造，析构的顺序正好相反。
//explicit限定构造函数时，可以防止隐式类型转换