/*继承的写法*/
class A     //已有的父类A
{
public:
	int A_a;
protected:
	int A_b;
private:
	int A_c;
};
//*公有继承
class B :public A
{
	//code
};
/*
此时的继承相当于
class B 
{
public:
	int A_a;
protected:
	int A_b;
};
*/
//*保护继承
class C :protected A
{
	//code
};
/*
此时的继承相当于
class B
{
protected:
	int A_b;
	int A_a;
};
*/

//*私有继承
class D : private A
{
	//code
};
/*
此时的继承相当于
class D
{
private:
	int A_b;
	int A_a;
};
*/


//*私有属性总是不能继承的，事实上是已经继承但访问不到

//*当子类中有与父类重名的变量时，默认时调用子类的变量，如果要调用父类的变量，需要调用时加上父类的作用域
//重名的方法与之类似，父类的被隐藏，想调用父类加作用域

//*继承中的静态变量的处理  （静态变量需要在类内声明，类外初始化）
//静态变量可以被子类继承，如果子类中有重名，同样隐藏父类的静态变量

//*多继承的概念
//class A :public B ,public C   多继承的写法
//多继承特别容易引发二义性的问题，因此一般不建议使用多继承

//菱形继承，羊和驼的例子，需要羊和驼的特征，而不需要两份年龄。一个基类派生两个类，两个类多继承，创建出新的类，导致有两个年龄
//解决办法是引入虚继承，例如有基类base ,B和C从base继承，B：v public base;  C :v public base;  此时如果A从B和C多继承，将共享一份年龄数据。


//父类引入一个虚函数，则引入了动态联编。
//多态：父类的引用或指针指向子类对象

/*
子类重写父类的虚函数，父类指针指向子类对象时，会调用子类的重写的函数  base  * bas = new son; 
其父类事实上只有一个指针指向虚函数表，当实例化子类的时候，指针指向的就是子类的重写虚函数，因此会执行子类的函数
*/